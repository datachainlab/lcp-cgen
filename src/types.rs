use attestation_report::EndorsedAttestationVerificationReport;
use commitments::CommitmentProof;
use ecall_commands::{
    AggregateMessagesInput, InitClientInput, UpdateClientInput, VerifyMembershipInput,
    VerifyNonMembershipInput,
};
use lcp_types::ClientId;
use serde::{Deserialize, Serialize};

pub trait JSONSerializer {
    fn to_json_string(&self) -> Result<String, anyhow::Error>;
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONEndorsedAttestationVerificationReport {
    /// Attestation report generated by the hardware
    pub avr: String,
    /// Singature of the report
    #[serde(with = "serde_base64")]
    pub signature: Vec<u8>,
    /// Certificate matching the signing key of the signature
    #[serde(with = "serde_base64")]
    pub signing_cert: Vec<u8>,
    /// mrenclave of the target enclave
    #[serde(with = "serde_base64")]
    pub mrenclave: Vec<u8>,
    /// address of enclave key
    #[serde(with = "serde_base64")]
    pub enclave_key: Vec<u8>,
}

impl JSONSerializer for EndorsedAttestationVerificationReport {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let this = self.clone();
        let avr = this.get_avr()?;
        let quote = avr.parse_quote()?;
        let report_data = quote.report_data();
        Ok(serde_json::to_string(
            &JSONEndorsedAttestationVerificationReport {
                avr: this.avr,
                signature: this.signature,
                signing_cert: this.signing_cert,
                mrenclave: quote.get_mrenclave().m.to_vec(),
                enclave_key: report_data.enclave_key().to_vec(),
            },
        )?)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONAny {
    type_url: String,
    #[serde(with = "serde_base64")]
    value: Vec<u8>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONInitClientInput {
    any_client_state: JSONAny,
    any_consensus_state: JSONAny,
    current_timestamp: u64, // second
}

impl JSONSerializer for InitClientInput {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let s = serde_json::to_string(&JSONInitClientInput {
            any_client_state: JSONAny {
                type_url: self.any_client_state.type_url.clone(),
                value: self.any_client_state.value.clone(),
            },
            any_consensus_state: JSONAny {
                type_url: self.any_consensus_state.type_url.clone(),
                value: self.any_consensus_state.value.clone(),
            },
            current_timestamp: self.current_timestamp.as_unix_timestamp_secs(),
        })?;
        Ok(s)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONInitClientResult {
    pub client_id: ClientId,
    pub proof: JSONCommitmentProof,
}

impl JSONSerializer for JSONInitClientResult {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        Ok(serde_json::to_string(self)?)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONUpdateClientInput {
    pub client_id: ClientId,
    pub any_header: JSONAny,
    pub include_state: bool,
    pub current_timestamp: u64, // seconds
}

impl JSONSerializer for UpdateClientInput {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let s = serde_json::to_string(&JSONUpdateClientInput {
            client_id: self.client_id.clone(),
            any_header: JSONAny {
                type_url: self.any_header.type_url.clone(),
                value: self.any_header.value.clone(),
            },
            include_state: self.include_state,
            current_timestamp: self.current_timestamp.as_unix_timestamp_secs(),
        })?;
        Ok(s)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONAggregateMessagesInput {
    #[serde(with = "serde_base64")]
    pub signer: Vec<u8>,
    pub messages: Vec<String>,
    pub signatures: Vec<String>,
    pub current_timestamp: u64, // seconds
}

impl JSONSerializer for AggregateMessagesInput {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let s = serde_json::to_string(&JSONAggregateMessagesInput {
            signer: self.signer.to_vec(),
            messages: self.messages.iter().map(base64::encode).collect(),
            signatures: self.signatures.iter().map(base64::encode).collect(),
            current_timestamp: self.current_timestamp.as_unix_timestamp_secs(),
        })?;
        Ok(s)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONCommitmentProof {
    #[serde(with = "serde_base64")]
    pub message: Vec<u8>,
    #[serde(with = "serde_base64")]
    pub signature: Vec<u8>,
}

impl JSONSerializer for CommitmentProof {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        Ok(serde_json::to_string(&JSONCommitmentProof {
            message: self.message.clone(),
            signature: self.signature.clone(),
        })?)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONVerifyMembershipInput {
    pub client_id: ClientId,
    #[serde(with = "serde_base64")]
    pub prefix: Vec<u8>,
    pub path: String,
    #[serde(with = "serde_base64")]
    pub value: Vec<u8>,
}

impl JSONSerializer for VerifyMembershipInput {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        Ok(serde_json::to_string(&JSONVerifyMembershipInput {
            client_id: self.client_id.clone(),
            prefix: self.prefix.clone(),
            path: self.path.clone(),
            value: self.value.clone(),
        })?)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONVerifyNonMembershipInput {
    pub client_id: ClientId,
    #[serde(with = "serde_base64")]
    pub prefix: Vec<u8>,
    pub path: String,
}

impl JSONSerializer for VerifyNonMembershipInput {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        Ok(serde_json::to_string(&JSONVerifyNonMembershipInput {
            client_id: self.client_id.clone(),
            prefix: self.prefix.clone(),
            path: self.path.clone(),
        })?)
    }
}

mod serde_base64 {
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S: Serializer>(v: &Vec<u8>, s: S) -> Result<S::Ok, S::Error> {
        let base64 = base64::encode(v);
        String::serialize(&base64, s)
    }

    pub fn deserialize<'de, D: Deserializer<'de>>(d: D) -> Result<Vec<u8>, D::Error> {
        let base64 = String::deserialize(d)?;
        base64::decode(base64.as_bytes()).map_err(serde::de::Error::custom)
    }
}
